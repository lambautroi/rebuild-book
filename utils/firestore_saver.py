import uuid
import argparse
import requests
import os
from fastapi import FastAPI
from google.cloud import firestore

# Import t·ª´ c√°c module trong h·ªá th·ªëng
from utils.source_gutenberg import search_gutenberg, download_book as download_gutenberg, auto_tag as tag_gutenberg
from utils.source_archive import search_archive, download_book as download_archive, auto_tag as tag_archive
from utils.source_standardebooks import search_standard_ebooks, download_book as download_standardebooks, auto_tag as tag_standard
from utils.text_splitter import split_into_chapters
from utils.epub_generator import generate_epub

from api.cover import router as cover_router

app = FastAPI()
# ƒêƒÉng k√Ω router cho API cover
app.include_router(cover_router)

# =====================
# H√†m h·ªó tr·ª£ ch·ªçn ngu·ªìn
# =====================
def load_book_from_source(source: str, keyword: str):
    if source == "gutenberg":
        results = search_gutenberg(keyword, max_results=1)
        if not results:
            raise Exception("Kh√¥ng t√¨m th·∫•y s√°ch t·ª´ Gutenberg.")
        book = results[0]
        content = download_gutenberg(book["book_id"])
        tags = tag_gutenberg(book["title"], book["author"])
        return book["title"], book["author"], content, tags

    elif source == "archive":
        results = search_archive(keyword, max_results=1)
        if not results:
            raise Exception("Kh√¥ng t√¨m th·∫•y s√°ch t·ª´ Archive.org.")
        book = results[0]
        content = download_archive(book["identifier"])
        tags = tag_archive(book["title"], book["author"])
        return book["title"], book["author"], content, tags

    elif source == "standardebooks":
        results = search_standard_ebooks(keyword, max_results=1)
        if not results:
            raise Exception("Kh√¥ng t√¨m th·∫•y s√°ch t·ª´ Standard Ebooks.")
        book = results[0]
        content_bytes = download_standardebooks(book["slug"])
        tags = tag_standard(book["title"], book["author"])
        return book["title"], book["author"], content, tags

    else:
        raise ValueError("Ngu·ªìn kh√¥ng h·ª£p l·ªá. D√πng: gutenberg, archive, standardebooks.")

# ====================
# MAIN ENTRY POINT
# ====================
def main():
    parser = argparse.ArgumentParser(description="RebuildBook - Rewrite Public Domain Books")
    parser.add_argument("--source", type=str, required=True, help="Ngu·ªìn s√°ch: gutenberg | archive | standardebooks")
    parser.add_argument("--keyword", type=str, required=True, help="T·ª´ kh√≥a t√¨m s√°ch (v√≠ d·ª•: 'tolstoy')")
    parser.add_argument("--style", type=str, default="formal and elegant literary", help="M√¥ t·∫£ phong c√°ch mu·ªën vi·∫øt l·∫°i")

    args = parser.parse_args()
    source = args.source.lower()
    keyword = args.keyword
    style = args.style

    print(f"üü¢ ƒêang t√¨m v√† t·∫£i s√°ch t·ª´ ngu·ªìn: {source} v·ªõi t·ª´ kh√≥a: '{keyword}'")

    # 1. T·∫£i s√°ch
    title, author, raw_text, tags = load_book_from_source(source, keyword)
    print(f"‚úÖ ƒê√£ t·∫£i s√°ch: '{title}' b·ªüi {author}")

    # 2. T√°ch ch∆∞∆°ng
    chapters = split_into_chapters(raw_text)
    print(f"üìö S·ªë ch∆∞∆°ng t√°ch ƒë∆∞·ª£c: {len(chapters)}")

    # 3. T·∫°o ID s√°ch
    book_id = str(uuid.uuid4())

    # 4. G·ªçi pipeline vi·∫øt l·∫°i s√°ch
    run_full_pipeline(
        book_id=book_id,
        title=title,
        author=author,
        tags=tags,
        source=source,
        raw_text=raw_text,
        chapters=chapters,
        style_description=style
    )

    print(f"üéâ Pipeline ho√†n t·∫•t. S√°ch ƒë√£ l∆∞u v·ªõi ID: {book_id}")

    # ===== Giai ƒëo·∫°n 4: T·∫°o EPUB =====
    print("üì¶ B·∫Øt ƒë·∫ßu t·∫°o file EPUB...")

    db = firestore.Client()
    style_id = "default"
    style_ref = db.collection("books").document(book_id).collection("styles").document(style_id)
    style_doc = style_ref.get()

    if not style_doc.exists:
        print("‚ùå Kh√¥ng t√¨m th·∫•y style ƒë·ªÉ t·∫°o EPUB.")
    else:
        style_data = style_doc.to_dict()
        title_epub = f"{title} ‚Äì Modern Style"
        author_epub = f"{author}, Rewritten by RebuildBook AI"
        chapters_rewritten = style_data.get("rewrittenChapters", [])
        cover_url = style_data.get("cover", {}).get("finalUrl")

        # T·∫£i ·∫£nh cover n·∫øu c√≥
        cover_path = None
        if cover_url:
            os.makedirs("temp", exist_ok=True)
            cover_path = f"temp/{book_id}_{style_id}_cover.jpg"
            with open(cover_path, "wb") as f:
                f.write(requests.get(cover_url).content)

        # T·∫°o EPUB
        epub_path = generate_epub(book_id, style_id, title_epub, author_epub, cover_path, chapters_rewritten)

        # Upload file l√™n Firebase Storage (d√πng requests ho·∫∑c SDK t√πy b·∫°n tri·ªÉn khai upload_file)
        from google.cloud import storage
        client = storage.Client()
        bucket = client.bucket("rebuildbook-2b609.firebasestorage.app")
        blob = bucket.blob(f"books/{book_id}/styles/{style_id}/book.epub")
        blob.upload_from_filename(epub_path)
        blob.make_public()
        epub_url = blob.public_url

        # Ghi l·∫°i v√†o Firestore
        style_ref.update({"epubUrl": epub_url})
        print(f"‚úÖ EPUB ƒë√£ ƒë∆∞·ª£c t·∫°o v√† upload th√†nh c√¥ng: {epub_url}")

# ====================
# Ch·∫°y main
# ====================
if __name__ == "__main__":
    main()
